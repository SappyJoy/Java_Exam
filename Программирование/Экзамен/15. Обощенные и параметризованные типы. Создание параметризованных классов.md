15. Обощенные и параметризованные типы. Создание параметризованных классов.

# Обощенные и параметризованные типы. Создание параметризованных классов.
## Назначение обобщённого программирования
*Обобщенное программирование* означает написание кода, который может быть неоднократно использован с объектами самых разных типов. Так, если нет желания программировать отдельные классы для составления коллекций из объектов типа `String` и `File`, достаточно собрать эти объекты в коллекцию, воспользовавшись единственным обобщенным классом `ArrayList`. И это всего лишь один простой пример обобщенного программирования.
### Преимущества параметров типа
До внедрения обобщенных классов в версии Java SE 5.0 обобщенное программирование на Java всегда реализовывалось посредством наследования. Так, в классе `ArrayList` просто поддерживался массив ссылок на класс `Object` следующим образом:
```Java
public class ArrayList // до появления обобщенных классов
{
	private Object[] elementData;
	public Object get(int i) { . . . }
	public void add(Object o) { . . . }
}
```
Такой подход порождает две серьезные проблемы. Всякий раз, когда извлекается значение, необходимо выполнить приведение типа, как показано ниже.
```Java
ArrayList files = new ArrayList();
String filename = (String) files.get(0);
```
Более того, в таком коде отсутствует проверка ошибок. Ничто не мешает добавить значения любого класса следующим образом:
```Java
files.add(new File("..."));
```
Этот вызов компилируется и выполняется без ошибок. Но затем попытка привести результат выполнения метода `get()` к типу `String` приведет к ошибке.

Обобщения предлагают лучшее решение: параметры типа. Класс `ArrayList` теперь принимает параметр типа, обозначающий тип элементов коллеции, как показано ниже. Благодаря этому код получается более удобочитаемым. Теперь становится сразу понятно, что этот конкретный списочный массив содержит объекты типа `String`. 
```Java
ArrayList<String> files = new ArrayList<>() ;
```
Данные о типах могут быть полезными и для компилятора. Так, в приведенном ниже вызове метода `get()` никакого приведения типов не требуется. Ведь компилятору известно, что возвращаемым типом является `String`, а не `Object`.
```Java
String filename = files.get(0);
```
Компилятору также известно, что у метода `add()` из класса `ArrayList<String>` имеется параметр типа `String`. Эго намного безопаснее, чем иметь дело с параметром типа `Object`. Теперь компилятор может проконтролировать, не подставлен ли объект неверного типа в исходном коде. Например, следующая строка кода не скомпилируется:
```Java
files. add (new File(". . ."));
// в коллекцию типа ArrayList<String>
// можно вводить только объекты типа String
```
## Определение простого обобщённого класса
*Обобщенным* называется класс с одной или несколькими переменными типа. Здесь в качестве примера рассматривается простой обобщенный класс `Pair`. Этот класс выбран для примера потому, что он позволяет сосредоточить основное внимание на механизме обобщений, не вдаваясь в подробности сохранения данных. Ниже приведен исходный код обобщенного класса `Pair`.
```Java
public class Pair<T>
{
	private T first;
	private T second;
	
	public Pair() { first = null; second = null; }
	public Pair(T first, T second)
		{ this.first = first; this.second = second; }
		
	public T getFirst() { return first; }
	public T getSecond() { return second; }
	
	public void setFirst(T newValue) { first = newValue; }
	public void setSecond(T newValue) { second = newValue; }
}
```
В классе `Pair` вводится переменная типа `Т`, заключенная в угловые скобки (`<>`) после имени самого класса. У обобщенного класса может быть больше одной переменной типа. Например, класс `Pair` можно было бы определить с разными типами для первого и второго поля следующим образом:
```Java
public class Pair<T, U> {...}
```
Переменные типа используются повсюду в определении класса для обозначения типов, возвращаемых методами, а также типов полей и локальных переменных. Ниже приведен пример объявления переменной типа.
```Java
private Т first; // использовать переменную типа
```
*Экземпляр* обобщенного типа создается путем подстановки имени типа вместо переменной типа следующим образом:
```Java
Pair<String>
```
Результат такой подстановки следует рассматривать как обычный класс с конструкторами:
```Java
Pair<String>()
Pair<String>(String, String)
```
и методами:
```Java
String getFirst()
String getSecond()
void setFirst(String)
void setSecond(String)
```
Иными словами, обобщенный класс действует как фабрика обычных классов. В примере программы применяется класс `Pair`. В статическом методе `minmаx()` осуществляется перебор элементов массива с одновременным вычислением минимального и максимального значений. Для возврата обоих значений используется объект типа `Pair`. Напомним, что в методе `compareTo()` сравниваются две строки и возвращается нулевое значение, если символьные строки одинаковы; отрицательное числовое значение — если первая символьная строка следует прежде второй в лексикографическом порядке; а иначе — положительное числовое значение.
```Java
public class PairTest {
    public static void main(String[] args) {
        String[] words = { "Mary", "had", "a", "little", "lamb" };
        Pair<String> mn = ArrayAlg.minmax(words);
        System.out.println("min = " + mn.getFirst());
        System.out.println("max = " + mn.getSecond());
    }
}

class ArrayAlg {

    /**
     * Получает символьные строки с минимальным и
     * максимальным значениями среди элементов массива
     * @param a - Массив символьных строк
     * @return Пара минимального и максимального значений или
     * пустое значение, если параметр a имеет пустое значение
     */
    public static Pair<String> minmax(String[] a) {
        if (a == null || a.length == 0) {
            return null;
        }
        String min = a[0];
        String max = a[0];
        for (int i = 0; i < a.length; i++) {
            if (min.compareTo(a[i]) > 0) min = a[i];
            if (max.compareTo(a[i]) < 0) max = a[i];
        }
        return new Pair<>(min, max);
    }
}
```
## Правила наследования обобщённых типов
 Рассмотрим в качестве примера класс
Employee и подкласс Manager. Является ли обобщенный класс Pair<Manager> подклассом, производным от обобщенного класса Pair<Employee>? Как ни странно, не
является. Например, следующий код не подлежит компиляции:
```Java
Manager[] topHonchos = . .
Pair<Employee> result = ArrayAlg.minmax(topHonchos); // ОШИБКА!
```