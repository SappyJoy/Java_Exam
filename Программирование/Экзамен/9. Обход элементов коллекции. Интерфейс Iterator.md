9. Обход элементов коллекции. Интерфейс Iterator.

# Обход элементов коллекции. Интерфейс Iterator.В состав интерфейса Iterator входят три метода:```Javapublic interface Iterator<E> {	Е next();	boolean hasNext();	void remove();}```Многократно вызывая метод `next()`, можно обратиться к каждому элементу коллекции по очереди. Но если будет достигнут конец коллекции, то метод `next()` сгенерирует исключение типа `NoSuchElementException`. Поэтому перед вызовом метода `next()` следует вызывать метод `hasNext()`. Этот метод возвращает логическое значение `true`, если у объекта итератора все еще имеются объекты, к которым можно обратиться. Если же требуется перебрать все элементы коллекции, то следует запросить итератор, продолжая вызывать метод `next()` до тех пор, пока метод `hasNext()` возвращает логическое значение `true`. В приведенном ниже примере показано, как все это реализуется непосредственно в коде.```JavaCollection<String> с = . . .;Iterator<String> iter = с.iterator();while (iter.hasNext()) {	String element = iter.next();	// сделать что-нибудь с элементом element}```Тот же самый код можно написать более компактно, организовав цикл в стиле `for each` следующим образом:```Javafor (String element : с){	// сделать что-нибудь с элементом element}```Компилятор просто преобразует цикл в стиле `for each` в цикл с итератором. Цикл в стиле `for each` подходит для любых объектов, класс которых реализует интерфейс `Iterable` со следующим единственным методом:```Javapublic interface Iterable<E>{	Iterator<E> iterator();}```Интерфейс `Collection` расширяет интерфейс `Iterable`. Поэтому цикл в стиле `for each` подходит для обращения к элементам любой коллекции из стандартной библиотеки.Начиная с версии Java SE 8, для перебора элементов коллекции можно даже не организовывать цикл. Для этого достаточно вызвать метод `forEachRemaining()` с лямбда-выражением, где употребляется элемент коллекции. Это лямбда-выражение вызывается с каждым из элементов до тех пор, пока их больше не останется в коллекции:```Javaiterator.forEachRemaining(element -> сделать что-нибудь с элементом element);```Порядок, в котором перебираются элементы, зависит от типа коллекции. Так, если осуществляется перебор элементов коллекции типа `ArrayList`, итератор начинает его с нулевого индекса, увеличивая последнее значение на каждом шаге итерации. Но если осуществляется перебор элементов коллекции типа `HashSet`, то они получаются в совершенно случайном порядке. Можно быть уверенным лишь в том, что за время итерации будут перебраны все элементы коллекции, хотя нельзя сделать никаких предположений относительно порядка их следования. Обычно это не особенно важно, потому что порядок не имеет значения при таких вычислениях, как, например, подсчет суммы или количества совпадений.Метод `remove()` из интерфейса `Iterator` удаляет элемент, который был возвращен при последнем вызове метода `next()`. Во многих случаях это имеет смысл, поскольку нужно проанализировать элемент, прежде чем решаться на его удаление. Но если требуется удалить элемент, находящийся на определенной позиции, то сначала придется его пройти. В приведенном ниже примере показано, как удалить первый элемент из коллекции символьных строк.```JavaIterator<String> it = с.iterator();it.next(); // пройти первый элемент коллекцииit.remove(); / / а теперь удалить его```Но важнее то, что между вызовами методов `next()` и `remove()` существует определенная связь. В частности, вызывать метод `remove()` не разрешается, если перед ним не был вызван метод `next()`. Если же попытаться сделать это, будет сгенерировано исключение типа `IllegalStateException`. А если из коллекции требуется удалить два соседних элемента, то нельзя просто вызвать метод `remove()` два раза подряд, как показано ниже.```Javait.remove();it.remove(); // ОШИБКА!```Вместо этого нужно сначала вызвать метод `next()`, чтобы пройти удаляемый элемент, а затем удалить его, как следует из приведенного ниже примера кода.```Javait.remove();it.next();it.remove(); // Допустимо!```