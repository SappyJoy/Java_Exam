7. Классы System и Runtime. Класс java.io.Console.

# Классы System и Runtime. Класс java.io.Console.
## Класс `System`
Класс `java.lang.System` является `final`, все поля и методы являются статическими (`static`), поэтому мы не можем создать подкласс и переопределить его методы используя наследование. Класс `Java System` не предоставляет каких-либо публичных конструкторов, поэтому мы не можем создать экземпляр этого класса.

### Пример работы с классом
Вызов метода из класса `java.lang.System` выглядит так: `System.out.print()`  — это один из самых простых способов логгирования информации.

Далее рассмотрим различные функции, предоставляемые классом `java.lang.System`.

### Пример использования Array Copy класса Java System
Класс `System` обеспечивает нативный метод для копирования данных из одного массива в другой. Это встроенный метод, поэтому должен работать быстрее, чем другие способы копирования массива. Метод `System.arraycopy` бросает исключение `IndexOutOfBoundsException` если копирование обратится к данным за пределами границ массива. Также он бросает `ArrayStoreException` если элемент в исходном массиве не может быть сохранен в массиве назначения из-за несоответствия типа. Еще может быть выброшен `NullPointerException`, если массив источник или массив назначения `null`.

Ниже приведен пример программы с примером использования этого метода:
```Java
// инициализируем массивы
int [] array1 = {1,2,3,4,5};
int[] array2 = {10,20,30,40,50};
 
// копируем первые 2 элемента с массива array1 в массив array2
// начиная со второго индекса массива array2
System.arraycopy(array1, 0, array2, 2, 2);
 
System.out.println(Arrays.toString(array2)); // [10, 20, 1, 2, 50]
```
### Читаем с консоли/пишем в консоль с помощью класса Java System
Класс `System` предоставляет удобный способ получить уникальный объект `Console`, связанный с управлением JVM. Класс `Console` был введен в Java IO версии Java SE 1.6 c полезным методом для печати отформатированных данных и безопасного считывания пароля. Если у вас консоль не связан с текущей JVM или работает в качестве фоновой программы, то на попытку получить объект `Console` возвращается значение `null`.

Ниже приведена программа получения объекта класса Console иго использование:
```Java
Console console = System.console();
// если удалось получить объект Console
if (console != null) {
	Calendar c = new GregorianCalendar();
	console.printf("Сайт %1$s%n", "Javadevblog.com"); //распечатает Сайт Javadevblog.com"
	console.printf("Текущее время: %1$tm %1$te,%1$tY%n", c); //печатаем "Текущее время: 13 12,2015"
	console.flush();
} else {
    System.out.println("Объект Console не получен");
}
```
### Получаем текущее время с помощью класса System
Класс `System` предоставляет два метода получения текущего времени в миллисекундах и наносекундах. Мы можем использовать время в миллисекундах, чтобы создать объект `Date`. Время в наносекундах используется в основном в научных экспериментах или тестировании производительности программ.

Ниже представлен фрагмент кода, показывающий использование методов класса `System` для получения текущего времени.
```Java
long currentTimeMillis = System.currentTimeMillis();
Date date = new Date(currentTimeMillis);
System.out.println("Текущее время в миллисекундах : " + currentTimeMillis);
System.out.println(date); 

long nanoTime = System.nanoTime();
System.out.println("Текущее время в наносекундах : " + nanoTime);
```

### Класс System. Переменные окружения
Класс `System` предоставляет метод получения переменных среды в виде неизменяемой `Map`, которая содержит пары ключ-значение по каждой переменной среды.
```Java
//получаем переменные среды в виде коллекции Map 
//и просматриваем каждую
Map<String, String> envMap = System.getenv();
Set<String> keySet = envMap.keySet();
for(String key : keySet){
    System.out.println("Ключ : " + key + " | значение : " + envMap.get(key));
}
 
// получаем определенную переменную среды
String pathValue = System.getenv("PATH");
System.out.println("$PATH=" + pathValue);
```
### Операции File IO с помощью класса System
Класс `System` содержит три поля — `in`, `out` и `err`. Они используются для чтения данных из `InputStream` и записи данных в `OutputStream`. Например, мы можем установить `FileOutputStream` к полю `out` и `err` для того, чтобы результат вывода в консоль записывался в файл.
```Java
 try(FileInputStream fis = new FileInputStream("input.txt");
        FileOutputStream fos = new FileOutputStream("server.log");) {
     
    //устанавливаем inputStream
    System.setIn(fis);
    char c = (char) System.in.read();
    System.out.print(c); //печатаем первый считанный знак
     
    //устанавливаем outputStream
    System.setOut(new PrintStream(fos));
    System.out.write("Привет, Java\n".getBytes());
     
    //устанавливаем errorStream
    System.setErr(new PrintStream(fos));
    System.err.write("Сообщение об исключении\n".getBytes());
} catch (IOException e) {
    e.printStackTrace();
}
```
## Класс `Runtime`
Класс `Runtime` инкапсулирует интерпретатор Java. Вы не можете создать нового представителя этого класса, но можете, вызвав его статический метод, получить ссылку на работающий в данный момент объект `Runtime`. Обычно апплеты и другие непривелигированные программы не могут вызвать ни один из методов этого класса, не возбудив при этом исключения `SecurityException`. Одна из простых вещей, которую вы можете проделать с объектом `Runtime` — его останов, для этого достаточно вызвать метод `exit(int code)`.
### Управление памятью
Хотя Java и представляет собой систему с автоматической сборкой мусора, вы для проверки эффективности своего кода можете захотеть узнать, каков размер “кучи” и как много в ней осталось свободной памяти. Для получения этой информации нужно воспользоваться методами `totalMemory()` и `freeMemory()`.

ВНИМАНИЕ!

При необходимости вы можете “вручную” запустить сборщик мусора, вызвав метод `gc`. Если вы хотите оценить, сколько памяти требуется для работы вашему коду, лучше всего сначала вызвать `gc()`, затем `freeMemory()`, получив тем самым оценку свободной памяти, доступной в системе. Запустив после этого свою программу и вызвав `freeMemory()` внутри нее, вы увидите, сколько памяти использует ваша программа.
### Выполнение других программ
В безопасных средах вы можете использовать Java для выполнения других полновесных процессов в своей многозадачной операционной системе. Несколько форм метода `ехес()` позволяют задавать имя программы и ее параметры.

В очередном примере используется специфичный для Windows вызов `ехес()`, запускающий процесс notepad — простой текстовый редактор. В качестве параметра редактору передается имя одного из исходных файлов Java. Обратите внимание — ехес автоматически преобразует в строке-пути символы "/" в разделители пути в Windows — "\".
```Java
class ExecDemo {
    public static void main(String args[]) {
        Runtime r = Runtime. getRuntime();
        Process p = null;
        System.out.println("Working Directory = " + System.getProperty("user.dir"));
        String cmd[] = { "notepad", System.getProperty("user.dir") + "/src/ExecDemo.java" };
        try {
            p = r.exec(cmd);
        } catch (Exception e) {
            System.out.println("error executing " + cmd[0]);
        }
        r.gc(); // Вызов сборщика мусора
        
        // Вывод задействованной памяти
        System.out.printf("Memory using: %.3f Mb", (double)(r.totalMemory() - r.freeMemory()) / (1024 * 1024));
    }
}
```