10. Сортировка элементов коллекций. Интерфейсы Comparable и Comparator.

# Сортировка элементов коллекций. Интерфейсы Comparable и Comparator.
Ветераны программирования иногда вспоминают о том, как им приходилось пользоваться перфокартами и программировать алгоритмы сортировки вручную. Ныне алгоритмы сортировки уже вошли в состав стандартных библиотек большинства языков программирования, и в этом отношении Java не является исключением. Так, метод `sort()` из класса `Collections` сортирует коллекцию, реализующую интерфейс `List`, следующим образом:
```Java
List<String> staff = new LinkedList<>();
// заполнить коллекцию
Collections.sort(staff);
```
В этом методе предполагается, что элементы списка реализуют интерфейс `Comparable`. Если же требуется отсортировать список каким-то другим способом, можно вызвать метод `sort()` из интерфейса `List`, передав ему объект типа Comparator в качестве параметра. Ниже показано, как отсортировать список элементов.
```Java
staff.sort(Comparator.comparingDouble(Employee::getSalary));
```
Если требуется отсортировать список по убывающей, следует воспользоваться служебным статическим методом `Comparator.reverseOrder()`. Он возвращает компаратор, который, в свою очередь, возвращает результат вызова `b.compareTo(а)`. Например, в приведенной ниже строке кода элементы списка `staff` сортируются в обратном порядке, который задается методом `compareTo()` для типа элементов списка.
```Java
staff.sort(Comparator.reverseOrder())
```
Аналогично в следующей строке кода порядок сортировки изменяется на обратный:
```Java
staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed())
```

Вас может заинтересовать, каким образом метод `sort()` сортирует список. Если проанализировать алгоритм сортировки, рассматриваемый в специальной литературе по алгоритмам, то он обычно поясняется на примере обычных массивов с произвольным доступом к элементам. Но ведь произвольный доступ к элементам списка неэффективен. Списки лучше сортировать, используя алгоритм сортировки слиянием. Но в реализации на Java этого не делается. Напротив, все элементы выводятся в массив, который затем сортируется с помощью другой разновидности сортировки слиянием, после чего отсортированная последовательность копируется обратно в список.

Алгоритм сортировки слиянием, применяемый в библиотеке коллекций, немного медленнее быстрой сортировки, традиционно выбираемой для алгоритмов сортировки общего назначения. Но у него имеется следующее важное преимущество: он устойчив, т.е. не меняет местами равнозначные элементы. А зачем вообще беспокоиться о порядке следования равнозначных элементов? Рассмотрим распространенный случай. Допустим, имеется список работников, который уже отсортирован по их Ф.И.О., а теперь их нужно отсортировать по зарплате. Как же будут отсортированы работники с одинаковой зарплатой? При устойчивой сортировке упорядочение по Ф.И.О. сохраняется. Иными словами, в конечном итоге получится список, отсортированный сначала по зарплате, а затем по Ф.И.О. работников.

В коллекциях не нужно реализовывать все "необязательные" методы, поэтому все методы, принимающие коллекции в качестве параметров, должны указывать, когда безопасно передавать коллекцию алгоритму. Например, совершенно очевидно, что вряд ли стоит передавать немодифицируемый список алгоритму сортировки. Какие же списки можно передавать? Согласно документации, список должен быть модифицируемым, но его размер не должен быть изменяемым. Ниже поясняется, что все это означает.

- Список является модифицируемым, если он поддерживает метод `set()`.
- Список имеет изменяемый размер, если он поддерживает методы `add()` и `remove()`.

В классе `Collections` реализован алгоритм перетасовки и соответствующий метод `shuffle()`, который выполняет задачу, противоположную сортировке, изменяя случайным образом порядок расположения элементов в списке, как показано в приведенном ниже примере кода.
```Java
ArrayList<Card> cards = . . .;
Collections.shuffle(cards);
```
Если предоставить список, который не реализует интерфейс `RandomAccess`, то метод `shuffle()` скопирует все его элементы в массив, перетасует этот массив, после чего скопирует перетасованные элементы обратно в список.
```Java
public class ShuffleTest {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= 49; i++) {
            numbers.add(i);
        }
        Collections.shuffle(numbers);
        List<Integer> winningCombination = numbers.subList(0, 6);
        Collections.sort(winningCombination);
        System.out.println(winningCombination);
    }
}
```
## Интерфейс `Comparable`
Интерфейс `Comparable` содержит один единственный метод `int compareTo(E item)`, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны. Пример его реализации в классе `Person`.
```Java
public int compareTo(Person p) {
    return name.length() - p.getName().length();
}
```
Теперь класс `Person`, можно сортировать и сравнивать.
## Интерфейс `Comporator`
Перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс `Comparable`, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить. На этот случай есть еще более гибкий способ, предполагающий применение интерфейса `Comparator<E>`.

Интерфейс `Comparator` содержит ряд методов, ключевым из которых является метод `compare()`:
```Java
public interface Comparator<E> {
    int compare(T a, T b);
    // остальные методы
}
```

Для применения интерфейса нам вначале надо создать класс компаратора, который реализует этот интерфейс:
```Java
class PersonComparator implements Comparator<Person>{
 
    public int compare(Person a, Person b){
     
        return a.getName().compareTo(b.getName());
    }
}
```
Здесь метод `compare()` идентичен одноименному методу из интерфейса `Comparable`, поэтому метод сравнения может быть достаточно сложным. Например:
```Java
public int compare(Person a, Person b){
  
    if(a.getAge()> b.getAge())
        return 1;
    else if(a.getAge()< b.getAge())
        return -1;
    else
        return 0;
}
```
Теперь можно сортировать список из объектов класса `Person`, передав в аргументы метода `sort()` компаратор.