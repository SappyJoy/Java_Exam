6. Обработка исключительных ситуаций. Классы Error, Exception, RuntimeException.

# Обработка исключительных ситуаций. Классы Error, Exception, RuntimeException.
## Обработка ошибок
Допустим, в ходе выполнения программы, написанной на Java, обнаружена ошибка. Вполне естественно, пользователи надеются, что программа самостоятельно справится с возникшими затруднениями. Если из-за ошибки какая-нибудь операция не может быть завершена благополучно, программа должна сделать одно из двух.
- Вернуться в **безопасное состояние** и разрешить пользователю выполнить другие команды.
- Дать пользователю возможность **сохранить результаты** своей работы и аккуратно завершить работу.

Добиться этого не так-то просто: фрагмент кода, в котором обнаруживается ошибка (или даже тот фрагмент кода, выполнение которого приводит к ошибке), обычно находится очень далеко от кода, который может восстановить данные и сохранить результаты, полученные пользователем. Поэтому основное назначение механизма *обработки исключений* - передать данные *обработчику исключений* из того места, где возник сбой.

Обычно метод сообщает об ошибке, возвращая специальный код, который анализируется вызывающим методом. Например, методы, вводящие данные из файлов, обычно возвращают значение **-1** по достижении конца файла. Такой способ обработки ошибок часто оказывается эффективным. В других случаях в качестве признака ошибки возвращается пустое значение **null**.

К сожалению, возможность возвращать код ошибки имеется далеко не всегда. Иногда правильные данные не удается отличить от признаков ошибок. Так, метод, возвращающий целое значение, вряд ли возвратит значение **-1**, обнаружив ошибку, поскольку оно может быть получено в результате вычислений.

В Java имеется возможность предусмотреть в каждом методе **альтернативный выход**, которым следует воспользоваться, если нормальное выполнение задания нельзя довести до конца. В этом случае метод не станет возвращать значение, а *сгенерирует* объект, инкапсулирующий сведения о возникшей ошибке. Следует, однако, иметь в виду, что выход из метода происходит незамедлительно, и он не возвращает своего нормального значения. Более того, возобновить выполнение вода, вызвавшего данный метод, невозможно. Вместо этого начинается поиск *обработчика исключений*, который может справиться с возникшей ошибочной ситуацией.

Исключения имеют свой собственный синтаксис и являются частью особой иерархии наследования.

## Классификация исключений
В языке Java объект исключения всегда является экземпляром класса, производного от класса `Throwable`. Если стандартных классов недостаточно, можно создавать свои собственные классы исключений.


![4db731774a10180708ea01937d83c0c5.png](../../_resources/e081033f8e8e45c2a8b718b5152d8040.png)

Обратите внимание но то, что иерархия наследования исключений сразу же равделяется на две ветви: `Error` и `Exception`. Иерархия класса `Error` описывает **внутренние ошибки** и ситуации, воникающие в связи с нехваткой ресурсов в исполняющий системе Java. Ни один объект этого класса *нельзя сгенерировать самостоятельно*. При возникновении внутренней ошибки в такой системе возможности разработчика прикладной программы крайне ограничены. Можно лишь уведомить пользователя и попытаться аккуратно прервать выполнение программы, хотя такие ситуации достаточно редки.

При программировании на Java основное внимание следует уделять иерархии класса `Exception`. Эта иерархия также разделяется на две ветви: исключения, производные от класса `RuntimeException`, и остальные. Искючения типа `RuntimeException` возникают вследствии **ошибок программирования**. Все другие виды исключений являются следствием нередвиденного стечения обстоятельств, например, ошибок ввода-вывода, возникающих при выполнении вполне корректных программ.

Исключения, производные от класса `RuntimeException`, сязаны со следующими программными ошибками. 
- Неверное приведение типов.
- Выход за пределы массива.
- Попытка обратиться к объекту по пустой ссылке `null`.

Остальные исключения возникают в следующих случаях.
- Попытка чтения по достижении конца файла.
- Попытка открыть несуществующий файл.
- Попытка получить объект типа `Class`, если в символьной строке указан несуществующий класс.

Исключения типа `RuntimeException` практически всегда возникают по вине программиста. Так, исключения типа `ArrayIndexOutBoundsException` можно избежать, если всегда проверять индексы массива. А исключение `NullPointerException` никогда не возникнет, если перед тем, как воспользоваться переменной, проверить, не содержит ли она пустое значение `null`.

А как быть, если файл не существует? Нельзя ли сначала проверить, существует ли он вообще? Дело в том, что файл может быть удалён сразу же после проверки его существования. Следовательно, понятие существования файла зависит от среды исполнения, а не от кода программы.

В спецификации языка Java любое исключение, производное от класса `Error` или `RuntimeException`, называется *нероверяемым*. Все остальные исключения *проверяемыми*. Для всех проверяемых исключений компилятор проверяет наличие соответствущих обработчиков.

## Объявление проверяемых исключений
Метод иожет генерировать исключения, если возникает ситуация, с которй он не в состоянии справиться. Идея проста: метод не только сообщает компилятору, какие значения он может возвращать, но и предсказывает, какие ошибки *могут* возникнуть.

Объявление о том, что данный метод может генерировать исключение, делается в его заголовке. Ниже в качестве примера приведено объявление одного из конструкторов класса `FileInputStream` из стандартной библиотеки.
```Java
public FileInputStream(String name) throws FileNotFoundException
```
Это объявление означает, что в определённых случаях, когда что-нибудь пойдёт не так, он может также сгенерировать исключение типа `FileNotFoundException`. Если это произойдёт, исполняющая система начнет поиск обработчика событий, предназначенного для обработки объектов типа `FileNotFoundException`.

Если метод может генерировать несколько проверяемых исключений, все они должны быть перечислены в его заголовке через запятую слудующим образом:
```Java
class MyAnimation {
	...
	public Image loadImage(String s)
			throws FileNotFoundException, EOFException {
		...		
	}
}
```
Если в объявлении метода указывается, что он может генерировать исключение определённого класса, то он может генерировать исключения его подклассов.

## Генерирование исключений
```Java
String readData(Scanner in) throws EOFException {
	...
	while (...) {
		if (!in.hasNext()) { // достигнут конец файла (признак EOF) 
			if (n < len)
				throw new EOFException();
		}
		...
	}
	return s;
}
```
## Перехват одного исключения
Если исключение возникает и нигде не перехватывается, то программа прекращает работу, вывод на консоль сообщение о типе исключения и содержимое стека.

Перехват исключения осуществляется в блоке `try/catch`. В простейшем случае этот блок имеет следующий вид:
```Java
try {
	// код
	// дополнительный код
	// дополнительный код
} catch (ТипИсключения e) {
	// обработчик исключения данного типа
}
```
Если фрагмент кода в блоке `try` генерирует исключение типа, указанного в заголовке блока `catch`, то происходит следующее.

1. Программа пропускает оставшуюся часть кода в блоке `try`.
2. Программа выполняет код обработчика в блоке `catch`.

## Перехват нескольких исключений
```Java
try {
	// код, способный генерировать исключения
} catch (FileNotFoundException | UnknownHostException e) {
	// чрезвычайные действия, если нужные файлы отсутствуют
	// или неизвестны хосты
} catch (IOException e) {
	// чрезвычайные действия во всех остальных
	// случаях появления ошибок ввода-вывода
}
```
## Повторное генерирование и связывание исключений в цепочку
Исключение можно генерировать и в блоке `catch`, образуя тем самым цепочку исключений. Обычно это делается для того, чтобы изменить тип исключения. Так, если разрабатывается подсистема для применения другими разработчиками, то имеет смысл генерировать такие исключения, которые давали бы возможность сразу определить, что ошибка возникла именно в этой подсистеме. В качестве характерного примера можно привести исключение типа `ServletException`. Впролен возможно, что в коде, где выполяется сервлет, совсем не обязательно иметь подробные сведения о том, какая именно возникла ошибка, а важно лишь знать, что сервлет работает некорректно. В приведённом ниже фрагменте кода показано, каким образом перехватывается и повторно генерируется исключение.
```Java
try {
	// получить доступ к базе данных
} catch (SQLException e) {
	Throwable se = new ServletException("database error");
	se.initCause(e);
	throw se;
}
```
Иногда требуется зарегистрировать исключение и сгенерировать его повторно без всяких изменений:
```Java
try {
	// получить доступ к базе данных
} catch (Exception e) {
	logger.log(level, message, e);
	throw e;
}
```
## Блок `finally`
Код в блоке `finally` выполняется независимо от того, возникло исключение или нет. Так, в приведенном ниже примере кода графический контекст освобождается при *люых условиях*.
```Java
InputStreat in = new FileInputStream(...);
try {
	// код, способный генерировать исключения
} catch (IOException e) {
	// вывести сообщение об ошибке
} finally {
	in.close();
}
```
## Оператор `try` с ресурсами
В простейшей форму оператор `try` с ресурсами выглядит следующим образом:
```Java
try (Resource res = ...) {
	// использовать ресурс res
}
```
Следует иметь ввиду, что эта конструкция эффективна при одном условии: используемый ресурс принадлежит классу, реализующему интерфейс `AutoCloseable`. В этом интерфейсе имеется единственный метод, объявляемый следующим образом
```Java
void close() throws Exception;
```


















