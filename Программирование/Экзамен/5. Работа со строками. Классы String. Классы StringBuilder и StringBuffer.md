5. Работа со строками. Классы String. Классы StringBuilder и StringBuffer.

# Работа со строками. Классы String. Классы StringBuilder и StringBuffer.

## Символьные строки
По существу, символьная строка Java представляет собой последовательность символов в Юникоде. Например, строка `"Java\u2122"` состоит из пяти символов. В языке Java отстутствует встроенный тип для символьных строк. Вместо этого в стандартной библиотеке Java содержится класс `String`. Каждая символьная строка, заключенная в кавычки, представляет собой экземпляр класса `String`:
```Java
String e = ""; // пустая строка
String greeting = "Hello";
```
## Подстроки
С помощью метода `substring()` из класса `String` можно выделить подстроку из отдельной символьной строки.
```Java
String greeting = "Hello";
String s = greeting.substring(0, 3); // s = "Hel"
```
## Сцепление строк
В языке Java, как и в большинстве других языков программирования, предоставляется возможность объединить две символьные строки, используя знак `+` операции сцепления.
```Java
String expletive = "Expletive";
String PG13 = "deleted";
String message = expletive + PG13; // message = "Expletivedeleted"
```
При сцеплении символьной строки со значением, не являющимся строковым, это значение преобразуется в строковое (с помощью вызова у объекта метода `toString()`).
```Java
int age = 13;
String rating = "PG" + age; // rating = "PG13"
```
Если требуется соединить вместе две символьные строки, разделяемые каким-нибудь знаком, для этой цели можно воспользоваться методом `join()`, как показано ниже.
```Java
String all = String.join(" / ", "S", "M", "L", "XL");
// в итоге переменная all содержит строку "S / M / L / XL"
```
## Принцип постоянства символьных строк
В классе `String` отсутствуют методы, которые позволяли бы *изменять* символы в существующей строке. Так, если требуется заменить символьную строку в переменной `greeting` с `"Hello"` на `"Help!"`, этого нельзя добиться одной лишь заменой двух последних символов. В языке Java можно внести необходимые изменения в строку, выполнив сцепление подстроки, которую требуется сохранить, с заменяющими символами, как показано ниже.
```Java
greeting = greeting.substring(0, 3) + "p!";
```
То есть изменить состав строки нельзя. Но, как мы только что убедились, можно изменить содержимое строковой переменной `greeting` и заставить её ссылаться на другую символьную строку подобно тому, как числовой переменной, в которой хранится число **3**, можно присвоить число **4**.

Да, при этом эффективность, конечно, падает. Но у неизменяемых строк имеется одно существенное преимущество: компилятор может сделать строки *совместно используемыми*

Чтобы стал понятнее принцип постоянства строк, представьте, что в общем пуле находятся разные символьные строки. Строковые переменные указывают на объекты в этом пуле. При копировании строковой переменной оригинал и копия содержат одну и ту же общую последовательность символов. Одним словом, создатели языка Java решили, что эффективность совместного использования памяти перевешивает неэффективность редактирования строк путем выделения и сцепления строк.

Посмотрите на свои программы. Чаще всего вы скорее сравниваете символьные строки, а не изменяете их. Разумеется, бывают случаи, когда непосредственные манипуляции символьными строками оказываются более эффективными. Одна из таких ситуаций возникает, когда нужно составить строку из отдельных символов, поступающих из файла или вводимых с клавиатуры. Для подобных ситуаций в языке Java предусмотрен отдельный класс `StringBuffer`.
## Проверка символьных строк на равенство
Чтобы проверить две символьные строки на равенство достаточно вызвать метод `equals()`.
```Java
"Hello!".equals(greeting);
"Hello".equalsIgnoreCase("hello") // игнорирую отличая в прописных и строчных буквах
```
Для проверки строк на равенство *нельзя* применять операцию `==`. Она лишь определяет, хрянятся ли обе строки в одной и той же области памяти.

## java.lang.String
| Метод | Описание |
|-------|----------|
|char charAt(int index) | Возвращает символ, расположенный на указанной позиции. Вызывать этот метод следует только в том случае, если интересуют низкоуровневые кодовые единицы. |
|int codePointAt(int index) | Возвращает кодовую точку, начала или конец которой находится на указанной позиции. |
|int offsetByCodePoints(int startIndex, int cpCount) | Возвращает индекс кодовой точки, которая отстоит на количество *cpCount* кодовых точек от исходной кодовой точки |
|... |... |

## Построение символьных строк
Время от времени у вас будет возникать потребность в составлении одних символьных строк из других, более коротких строк, вводимых с клавиатуры или из файла. Было бы неэффективно постоянно пользоваться для этой цели сцеплением строк. Ведь при каждом сцеплении символьных строк конструируется новый объект типа `String`, на что расходуется время и пямять. Этого можно избежать, применяя класс `StringBuilder`.

Если требуется создать символьную строку из нескольких небольших фрагментов, сконструируйте сначала пустой объект в качестве построителя символьной строки:
```Java
StringBuilder builder = new StringBuilder();
```
Когда же потребуется добавить новый фрагмент в символьную строку, вызовите метод append(), как показано ниже.
```Java
builder.append(ch); // добавить единственный символ
builder.append(str); // добавить символьную строку

// соединять можно цепочкой
new StringBuilder().append(s1).append(s2).append(s3).toString();
```
Завершив составление символьной строки, вызовите метод `toString()`. Таким образом, вы получите объект типа `String`, состоящий из последовательности символов, содержащихся в объекте построителя символьных строк:
```Java
String completedString = builder.toString();
```

Класс `StringBuilder` идентичен классу `StringBuffer` и обладает большей производительностью. Однако он не синхронизирован, поэтому его не нужно использовать в тех случаях, когда к изменяемой строке обращаются несколько потоков.